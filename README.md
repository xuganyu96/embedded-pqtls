# Post-quantum TLS 1.3 on embedded device
Content of this repository:
- **pico**: C project for running TLS client on Raspberry Pi Pico 2 W
- **server-wolfssl**: TLS client, server, and certificate generator on desktop environment
- **wolfssl**: a fork of WolfSSL that contains the modifications
- **certificates**: ready-made certificate chains

## Getting started
To evaluate post-quantum TLS 1.3 or KEMTLS, start with cloning the repository, including all submodules:

```bash
git clone git@github.com:xuganyu96/embedded-pqtls.git --recurse-submodules
```

First build the server project, under `/server`. The server project depends on a fork of WolfSSL and a fork of PQClean, although these two dependencies have been cloned as submodules, so they should not require manual intervention. This project builds four binaries:
- `certgen` for generating a certificate chain
- `asn1` for inspecting the output of `certgen`
- `tls13server` for TLS 1.3 (or KEMTLS) server
- `tls13client` for TLS 1.3 or KEMTLS client

```bash
cd server
mkdir build
cd build
cmake .. && make
```

To evaluate TLS 1.3 or KEMTLS with any kind of authentication, certificates and private key files are necessary. They can be generated by the `certgen` program and inspected by the `asn1` program. The choice of digital signature algorithm is specified in the `src/certgen.c` source file.

```bash
# project/server/build
mkdir -p certs
./certgen certs
# .crt is a certificate, .key is a private key, all in PEM format
./asn1 --pem --indent --no-dump-text --branch certs/<root|int|leaf|client>.<key|crt>
```

Server and client can be independently run. For server authentication only, server needs `--certs` and `--key`, and client needs `--cafile`; for mutual authentication (TLS 1.3 only), server additionally needs `--cafile` while client needs `--certs` and `--key`. All desktop programs are compiled with `DEBUG_WOLFSSL` flag, but actual debugging messages are printed iff `--debug` flag is given.

```bash
# in separate terminals
./tls13server [--debug] --certs server-chain.crt --key leaf.key [--cafile root.crt] <port>
./tls13client [--debug] --cafile root.crt [--certs client-chain.crt --key client.key] <hostname> <port>
```

Server and client will perform a handshake, then exchange a small amount of TLS-protected application data to ensure that the connection works. Finally, a convenient script `handshake.sh <certdir>` will run both the server and the client (server in the background, client in the foreground, and the server will be killed after the client exits) for a quick validation.

After the certificate chain is validated on the desktop, we can move onto the Pico. The `pico` project additionally requires the Pico-SDK, though the repository is not included as a submodule. Instead, refer to Raspberry Pi's documentation for setting up the SDK. This project also requires a number of environment variables at compile time, but they contain secrets such as Wifi passwords and IP addresses, so you will have to manage it yourself:

```bash
# DO NOT COMMIT
export WIFI_SSID="..."
export WIFI_PASSWORD="..."
export TEST_TCP_SERVER_IP="..."
export TEST_TCP_SERVER_HOSTNAME="..."
export TEST_TCP_SERVER_PORT="..."
```

After Pico-SDK and ARM toolchain is set up, we need to set up a header file that contains the root certificate. This is because this Pico project is bare-metal and has no file system, which means that the root certificate has to be loaded as a `char *` buffer. The recommended practice is to add to `pico/include/pico-pqtls/cafiles/<scheme>.h`. See `pico/src/tls_client.c` for an example.

Before building and running the Pico client, we first need to run the server:

```
CERTDIR="..."
./tls13server
```

Now let's build the firmware and load it into the Pico.

```bash
mkdir -p build
cd build
cmake .. && make
# connect the Pico
picotool load -f tls_client.uf2
# read serial output from Pico and write to file
../readserial.py /dev/tty.usbmodemXXX -C serial.log
```

## Future works
- Mutually authenticated KEMTLS
- Pico as a TLS/KEMTLS server

## Bibliography
```bibtex
@InProceedings{CCS:SchSteWig20,
  author =       "Peter Schwabe and
                  Douglas Stebila and
                  Thom Wiggers",
  title =        "Post-Quantum {TLS} Without Handshake Signatures",
  pages =        "1461--1480",
  editor =       ccs20ed,
  booktitle =    ccs20name,
  address =      ccs20addr,
  month =        ccs20month,
  publisher =    ccspub,
  year =         2020,
  doi =          "10.1145/3372297.3423350",
}

@InProceedings{ESORICS:SchSteWig21,
  author =       "Peter Schwabe and
                  Douglas Stebila and
                  Thom Wiggers",
  title =        "More Efficient Post-quantum {KEMTLS} with Pre-distributed Public Keys",
  pages =        "3--22",
  editor =       esorics21ed,
  booktitle =    esorics21name1,
  volume =       esorics21vol1,
  address =      esorics21addr,
  month =        esorics21month,
  publisher =    esorics21pub,
  series =       mylncs,
  year =         2021,
  doi =          "10.1007/978-3-030-88418-5_1",
}

@Misc{EPRINT:GonWig22,
  author =       "Ruben Gonzalez and
                  Thom Wiggers",
  title =        "{KEMTLS} vs. Post-Quantum {TLS}: Performance On Embedded Systems",
  year =         2022,
  howpublished = "Cryptology ePrint Archive, Report 2022/1712",
  url =          "https://eprint.iacr.org/2022/1712",
}
```

# Dev environment setup
```yaml
# wolfssl/.clangd 
CompileFlags:
  Add: [
    "-Wall",
    "-Wextra",
    "-DWOLFSSL_USER_SETTINGS",
    "-I/path/to/wolfssl",
    "-I/path/to/server/config",
  ]
```

```yaml
# .clang-format
BasedOnStyle: LLVM
TabWidth: 4
IndentWidth: 4
UseTab: Never
```
